// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gen

import (
	"context"
	"time"
)

const addMediaToFailedQueue = `-- name: AddMediaToFailedQueue :exec
WITH topic_lookup AS (
    SELECT id as topic_id FROM tg_topics WHERE message_thread_id = $1 LIMIT 1
)
insert into tg_queue_failed
    (topic_id, media_id, tag_id, error)
select topic_id, $2, $3, $4
from topic_lookup
`

type AddMediaToFailedQueueParams struct {
	MessageThreadID int    `json:"message_thread_id"`
	MediaID         int    `json:"media_id"`
	TagID           int    `json:"tag_id"`
	Error           string `json:"error"`
}

func (q *Queries) AddMediaToFailedQueue(ctx context.Context, arg AddMediaToFailedQueueParams) error {
	_, err := q.db.Exec(ctx, addMediaToFailedQueue,
		arg.MessageThreadID,
		arg.MediaID,
		arg.TagID,
		arg.Error,
	)
	return err
}

const clearFailedMediaFromQueue = `-- name: ClearFailedMediaFromQueue :exec
delete from tg_queue where media_id = $1
`

func (q *Queries) ClearFailedMediaFromQueue(ctx context.Context, mediaID int) error {
	_, err := q.db.Exec(ctx, clearFailedMediaFromQueue, mediaID)
	return err
}

const getConfig = `-- name: GetConfig :one
select
    tc.id,
    tc.slug,
    tc.recent_upload_time,
    tc.settings
from tg_config tc
where tc.slug = $1
`

func (q *Queries) GetConfig(ctx context.Context, slug string) (TgConfig, error) {
	row := q.db.QueryRow(ctx, getConfig, slug)
	var i TgConfig
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.RecentUploadTime,
		&i.Settings,
	)
	return i, err
}

const getMediaDataTelegram = `-- name: GetMediaDataTelegram :one
SELECT md.media_id, md.value
FROM media_data md
WHERE
	md.media_id = $1
	AND md.data_type = 'telegram'::media_data_type
limit 1
`

type GetMediaDataTelegramRow struct {
	MediaID int    `json:"media_id"`
	Value   string `json:"value"`
}

func (q *Queries) GetMediaDataTelegram(ctx context.Context, mediaID int) (GetMediaDataTelegramRow, error) {
	row := q.db.QueryRow(ctx, getMediaDataTelegram, mediaID)
	var i GetMediaDataTelegramRow
	err := row.Scan(&i.MediaID, &i.Value)
	return i, err
}

const getRecentUploadTime = `-- name: GetRecentUploadTime :one
select recent_upload_time from tg_config where slug = $1
`

func (q *Queries) GetRecentUploadTime(ctx context.Context, slug string) (time.Time, error) {
	row := q.db.QueryRow(ctx, getRecentUploadTime, slug)
	var recent_upload_time time.Time
	err := row.Scan(&recent_upload_time)
	return recent_upload_time, err
}

const linkMediaToTelegram = `-- name: LinkMediaToTelegram :exec
insert into media_data
    (media_id, data_type, value)
values ($1, 'telegram'::media_data_type, $2)
`

type LinkMediaToTelegramParams struct {
	MediaID int    `json:"media_id"`
	Value   string `json:"value"`
}

func (q *Queries) LinkMediaToTelegram(ctx context.Context, arg LinkMediaToTelegramParams) error {
	_, err := q.db.Exec(ctx, linkMediaToTelegram, arg.MediaID, arg.Value)
	return err
}

const listAllTopics = `-- name: ListAllTopics :many
select tt.id, tt.message_thread_id, tt.tag_id, tt.name, tt.icon_custom_emoji_id, tt.created, t.name as tag
from tg_topics tt
join tag t on t.id = tt.tag_id
`

type ListAllTopicsRow struct {
	ID                uint64     `json:"id"`
	MessageThreadID   int        `json:"message_thread_id"`
	TagID             int        `json:"tag_id"`
	Name              string     `json:"name"`
	IconCustomEmojiID *string    `json:"icon_custom_emoji_id"`
	Created           *time.Time `json:"created"`
	Tag               string     `json:"tag"`
}

func (q *Queries) ListAllTopics(ctx context.Context) ([]ListAllTopicsRow, error) {
	rows, err := q.db.Query(ctx, listAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllTopicsRow{}
	for rows.Next() {
		var i ListAllTopicsRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageThreadID,
			&i.TagID,
			&i.Name,
			&i.IconCustomEmojiID,
			&i.Created,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaQueue = `-- name: ListMediaQueue :many
select
    tq.id cursor,
    tq.media_id,
    m.title,
    m.teaser,
    m.file_url,
    tt.message_thread_id,
    m.occurrence_date,
    m.issue_date,
    m.duration,
    m.size,
    t.id as tag_id,
    t.name as tag
from tg_queue tq
join tag t on t.id = tq.tag_id
join tg_topics tt on tt.id = tq.topic_id
join media m on m.id = tq.media_id
where 
    m.file_url is not null
    and tq.id > $1 -- $1 is the last id in the previous query = cursor
order by m.occurrence_date asc
limit $2
`

type ListMediaQueueParams struct {
	ID    uint64 `json:"id"`
	Limit int32  `json:"limit"`
}

type ListMediaQueueRow struct {
	Cursor          uint64         `json:"cursor"`
	MediaID         int            `json:"media_id"`
	Title           string         `json:"title"`
	Teaser          *string        `json:"teaser"`
	FileUrl         *string        `json:"file_url"`
	MessageThreadID int            `json:"message_thread_id"`
	OccurrenceDate  time.Time      `json:"occurrence_date"`
	IssueDate       *time.Time     `json:"issue_date"`
	Duration        *time.Duration `json:"duration"`
	Size            *int           `json:"size"`
	TagID           int            `json:"tag_id"`
	Tag             string         `json:"tag"`
}

func (q *Queries) ListMediaQueue(ctx context.Context, arg ListMediaQueueParams) ([]ListMediaQueueRow, error) {
	rows, err := q.db.Query(ctx, listMediaQueue, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMediaQueueRow{}
	for rows.Next() {
		var i ListMediaQueueRow
		if err := rows.Scan(
			&i.Cursor,
			&i.MediaID,
			&i.Title,
			&i.Teaser,
			&i.FileUrl,
			&i.MessageThreadID,
			&i.OccurrenceDate,
			&i.IssueDate,
			&i.Duration,
			&i.Size,
			&i.TagID,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeTopicPublished = `-- name: MakeTopicPublished :exec
update tg_topics
set 
    message_thread_id = $1,
    created = now()
where id = $2
`

type MakeTopicPublishedParams struct {
	MessageThreadID int    `json:"message_thread_id"`
	ID              uint64 `json:"id"`
}

func (q *Queries) MakeTopicPublished(ctx context.Context, arg MakeTopicPublishedParams) error {
	_, err := q.db.Exec(ctx, makeTopicPublished, arg.MessageThreadID, arg.ID)
	return err
}

const populateMedia = `-- name: PopulateMedia :exec
insert into tg_queue (topic_id, media_id, tag_id)
SELECT tt.id, m.id, mt.tag_id
FROM media m 
JOIN media_tag mt ON m.id = mt.media_id 
JOIN tag t ON t.id = mt.tag_id 
JOIN tg_topics tt ON tt.tag_id = mt.tag_id 
left join tg_queue tq on tq.media_id = m.id
WHERE
	m.occurrence_date > $1 
	AND m.file_url IS NOT NULL
	AND tq.media_id IS NULL
ORDER BY m.occurrence_date ASC
`

func (q *Queries) PopulateMedia(ctx context.Context, occurrenceDate time.Time) error {
	_, err := q.db.Exec(ctx, populateMedia, occurrenceDate)
	return err
}

const populateMediaWithTagID = `-- name: PopulateMediaWithTagID :exec
insert into tg_queue (topic_id, media_id, tag_id)
SELECT tt.id, m.id, mt.tag_id
FROM media m 
JOIN media_tag mt ON m.id = mt.media_id 
JOIN tag t ON t.id = mt.tag_id 
JOIN tg_topics tt ON tt.tag_id = mt.tag_id 
left join tg_queue tq on tq.media_id = m.id
WHERE
	m.occurrence_date > $1 
    AND t.id = $2
	AND m.file_url IS NOT NULL
	AND tq.media_id IS NULL
ORDER BY m.occurrence_date ASC
`

type PopulateMediaWithTagIDParams struct {
	OccurrenceDate time.Time `json:"occurrence_date"`
	ID             int       `json:"id"`
}

func (q *Queries) PopulateMediaWithTagID(ctx context.Context, arg PopulateMediaWithTagIDParams) error {
	_, err := q.db.Exec(ctx, populateMediaWithTagID, arg.OccurrenceDate, arg.ID)
	return err
}

const removeMediaQueue = `-- name: RemoveMediaQueue :exec
delete from tg_queue where media_id = $1 and tag_id = $2
`

type RemoveMediaQueueParams struct {
	MediaID int `json:"media_id"`
	TagID   int `json:"tag_id"`
}

func (q *Queries) RemoveMediaQueue(ctx context.Context, arg RemoveMediaQueueParams) error {
	_, err := q.db.Exec(ctx, removeMediaQueue, arg.MediaID, arg.TagID)
	return err
}

const setRecentUploadTime = `-- name: SetRecentUploadTime :exec
update tg_config 
set recent_upload_time = $1
where slug = $2
`

type SetRecentUploadTimeParams struct {
	RecentUploadTime time.Time `json:"recent_upload_time"`
	Slug             string    `json:"slug"`
}

func (q *Queries) SetRecentUploadTime(ctx context.Context, arg SetRecentUploadTimeParams) error {
	_, err := q.db.Exec(ctx, setRecentUploadTime, arg.RecentUploadTime, arg.Slug)
	return err
}
