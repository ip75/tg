// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package gen

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"
)

type MediaDataType string

const (
	MediaDataTypeVideo    MediaDataType = "video"
	MediaDataTypeImage    MediaDataType = "image"
	MediaDataTypeTelegram MediaDataType = "telegram"
)

func (e *MediaDataType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MediaDataType(s)
	case string:
		*e = MediaDataType(s)
	default:
		return fmt.Errorf("unsupported scan type for MediaDataType: %T", src)
	}
	return nil
}

type NullMediaDataType struct {
	MediaDataType MediaDataType `json:"media_data_type"`
	Valid         bool          `json:"valid"` // Valid is true if MediaDataType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMediaDataType) Scan(value interface{}) error {
	if value == nil {
		ns.MediaDataType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MediaDataType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMediaDataType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MediaDataType), nil
}

// Дополнительные атрибуты объекта
type MediaDatum struct {
	ID       int           `json:"id"`
	MediaID  int           `json:"media_id"`
	DataType MediaDataType `json:"data_type"`
	Value    string        `json:"value"`
}

// Связка лекции и ключевых слов
type MediaTag struct {
	MediaID int `json:"media_id"`
	TagID   int `json:"tag_id"`
}

// Лекция, книга, статья
type Medium struct {
	ID             int            `json:"id"`
	Title          string         `json:"title"`
	Teaser         *string        `json:"teaser"`
	Text           *string        `json:"text"`
	OccurrenceDate time.Time      `json:"occurrence_date"`
	IssueDate      *time.Time     `json:"issue_date"`
	FileUrl        *string        `json:"file_url"`
	Visible        bool           `json:"visible"`
	Duration       *time.Duration `json:"duration"`
	Size           *int           `json:"size"`
}

// Справочник ключевых слов
type Tag struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// Config for sending messages. For future use when will be many chatbots on one server
type TgConfig struct {
	ID uint64 `json:"id"`
	// Unique slug for config. Used for getting config by slug
	Slug string `json:"slug"`
	// Last time updated topics for telegram, updated when recent audio sent to topic.
	RecentUploadTime time.Time `json:"recent_upload_time"`
	// Bot settings for sending messages.
	Settings json.RawMessage `json:"settings"`
}

type TgQueue struct {
	ID      uint64 `json:"id"`
	TopicID int    `json:"topic_id"`
	MediaID int    `json:"media_id"`
	TagID   int    `json:"tag_id"`
}

type TgQueueFailed struct {
	ID      uint64 `json:"id"`
	TopicID int    `json:"topic_id"`
	MediaID int    `json:"media_id"`
	TagID   int    `json:"tag_id"`
	Error   string `json:"error"`
}

type TgTopic struct {
	ID                uint64     `json:"id"`
	MessageThreadID   int        `json:"message_thread_id"`
	TagID             int        `json:"tag_id"`
	Name              string     `json:"name"`
	IconCustomEmojiID *string    `json:"icon_custom_emoji_id"`
	Created           *time.Time `json:"created"`
}
